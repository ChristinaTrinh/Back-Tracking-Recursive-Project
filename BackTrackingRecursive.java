//This project contains Back tracking recursive methods
//Methods use explore methods to help explore different paths and find the appropriate ones

public class BackTrackingRecursive {
    public static void main(String[] args) {
        waysToClimb(4);
        countBinary(3);
        String[] list = { "Janet", "Robert", "Morgan", "Char" };
        subsets(list);
        int[] list1 = { 7, 30, 8, 22, 6, 1, 14 };
        System.out.println(maxSum(list1, 19));
        printSquares(200);
    }

    // Write a recursive method called waysToClimb that takes a positive integer
    // value representing a number of stairs
    // and prints each unique way to climb a staircase of that height, taking
    // strides of one or two stairs at a time
    public static void waysToClimb(int height) {
        exploreWaysToClimb(height, 0, "");
    }

    private static void exploreWaysToClimb(int targetHeight, int currentHeight, String path) {
        if (currentHeight == targetHeight)
            System.out.println("[" + path.substring(2) + "]");
        else if (currentHeight < targetHeight) {
            exploreWaysToClimb(targetHeight, currentHeight + 1, path + ", 1");
            exploreWaysToClimb(targetHeight, currentHeight + 2, path + ", 2");
        }
    }

    // countBinary that accepts an integer n as a parameter and
    // prints all binary numbers that have exactly n digits in ascending order, each
    // on its own line.
    // All n digits should be shown for all num- bers, including leading zeros if
    // necessary.
    // Assume that n is nonnegative.
    // If n is 0, a blank line should be produced.
    public static void countBinary(int n) {
        exploreCountBinary(n, 0, "");
    }

    private static void exploreCountBinary(int targetDigit, int currentDigit, String path) {
        if (currentDigit == targetDigit)
            System.out.println(path);
        else if (currentDigit < targetDigit) {
            exploreCountBinary(targetDigit, currentDigit + 1, path + "0");
            exploreCountBinary(targetDigit, currentDigit + 1, path + "1");
        }
    }

    // subsets finds every possible sub-list of a given list.
    // A sub-list of a list L contains 0 or more of L’s elements.
    // The method accepts a list of strings as its parameter and
    // print every sub-list that could be created from elements of that list, one
    // per line
    public static void subsets(String[] list) {
        exploreSubsets(list, 0, "");
    }

    private static void exploreSubsets(String[] list, int i, String set) {
        if (i == list.length - 1) {
            System.out.println("[" + set + list[list.length - 1] + "]");
            if (set.length() > 0)
                System.out.println("[" + set.substring(0, set.length() - 2) + "]");
            else
                System.out.println("[]");
        } else if (i < list.length - 1) {
            exploreSubsets(list, i + 1, set + list[i] + ", ");
            exploreSubsets(list, i + 1, set);
        }
    }

    // maxSum that accepts a list of integers, L, and an integer limit n as
    // parameters and
    // uses backtracking to find the maximum sum that can be generated by adding
    // elements of L that do not exceed n.
    // For example, if you are given the list [7, 30, 8, 22, 6, 1, 14] and the limit
    // of 19,
    // the maximum sum that can be generated that does not exceed is 16, achieved by
    // adding 7, 8, and 1.
    // If the list L is empty, or if the limit is not a posi- tive integer, or all
    // of L’s values exceed the limit, return 0.
    public static int maxSum(int[] list, int limit) {
        return exploreMaxSum(list, limit, 0, 0, 0);
    }

    private static int exploreMaxSum(int[] list, int limit, int currentSum, int pastSum, int i) {
        int k = 0;
        if (i == list.length - 1) {
            if (currentSum > pastSum && currentSum <= limit)
                pastSum = currentSum;
            if (currentSum + list[list.length - 1] > pastSum && currentSum + list[list.length - 1] <= limit)
                pastSum = currentSum + list[list.length - 1];
            return pastSum;
        } else if (currentSum < limit && i < list.length) {
            pastSum = exploreMaxSum(list, limit, currentSum + list[i], pastSum, i + 1);
            pastSum = exploreMaxSum(list, limit, currentSum, pastSum, i + 1);
        }
        return pastSum;
    }

    // printSquares to find all ways to express an integer as a sum of squares of
    // unique positive integers.
    public static void printSquares(int target) {
        explorePrintSquares(target, 0, (int) Math.sqrt(target), 1, "");
    }

    private static void explorePrintSquares(int target, int currentSum, int maxInt, int currentInt, String path) {
        if (currentSum == target)
            System.out.println(path.substring(0, path.length() - 3));
        else if (currentSum < target && currentInt <= maxInt) {
            explorePrintSquares(target, currentSum + (int) Math.pow(currentInt, 2), maxInt, currentInt + 1,
                    path + currentInt + "^2 + ");
            explorePrintSquares(target, currentSum, maxInt, currentInt + 1, path);
        }
    }
}
